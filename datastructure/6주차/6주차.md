#6주차-1
O(n^2)에 해당하는 정렬 - 선택 삽입, 버블, 쉘
O(nlog2n)에 해당하는 정렬 - 합병, 퀵, 히프, 기수정렬

선택 정렬
삽입 정렬
버블 정렬
쉘 정렬

중 가장 우수한 정렬은?

1. 합병정렬

        - 분할과 정복기법에 기반

        - 분할 정복 알고리즘은 문제의 입력을 분할하고, 분할된 부분 문제들을 정복하여
          부분해를 구하고, 이들을 취합하는 방식으로 문제를 해결

        - 합병 정렬은 리스트를 두개의 균등한 크기로 분할하고,
          분할된 각 부분 리스트를 정렬하고 2개의 정렬된 부분 리스트를 합병하는 방법

        ex)
            입력파일: (27 10 12 20 25 13 15 22)

                  1) 분할(Divide) : 2개 부분 배열로 분리: (27 10 12 20), (25 13 15 22)

                  2) 정복(Conquer) : 각 부분 배열 정렬 (10 12 20 27), (13 15 22 25)

                  3) 결합(Combine) : 2개의 정렬된 부분 배열 통합 (10 12 13 15 20 22 25 27)

            27 10 12 20 25 13 15 22 -> 8

        27 10 12 20        25 13 15 22 # 균등 분할 -> 4 (부분의 개수는 2개)

    27 10     12 20       25 13    15 22  #균등 분할 -> 2 (부분의 개수는 4개)

   27    10   12   20   25   13   15   22   #비교 수행 -> 1 (부분의 개수는 8개)

    10 27     12 20      13 25     15 22    #병합

      10 12 20 27        13 15 22 25  #병합

        10 12 13 15 20 22 25 27   #병합

        - 원소 개수 8개일 경우 3번 분할 = n/2^k = 1   -> k = log2n


          1-1. 합병정렬 알고리즘
          merge_sort(list: array of integers, left, right: integer)
          {
                    if left < right then
                            mid = (left + right)/2
                            merge_sort(list, left, mid);  #재귀 호출
                            merge_sort(list, mid +1, right); #재귀 호출
                            merge(list, left, mid, right);
                    endif
          }


          1-2. merge() : 합병 과정

          1. 임시 배열 sorted 사용

          2. 2개 배열로부터 원소를 작은 순서대로 sorted에 이동

          3. 어느 한개의 리스트가 소진될 때까지 위 단계를 반복

          4. 다른 리스트의 나머지 원소들을 sorted에 이동


          1-3. 합병 알고리즘
          merge(a: array of integers, low, mid, high: integer)
          {
                  b1, b2, e1, e2, idx: integer
                  sorted: array of integers

                  b1 <- low: e1 <- mid; //첫번째 배열 인덱스: (하한, 상한)
                  b2 <- mid+1, e2 <- high // 두번쨰 배열 인덱스: (하한, 상한)            
                  index <- low; //sorted 배열 인덱스

                  // 2개 배열을 sorted 배열로 합병
                  // 2개 배열 원소를 비교하여 오름차순으로 sorted로 이동
                  // 한 배열이 소진되면, 다른 배열의 나머지 원소들을 sorted로 이동
                  // sorted 배열을 원래의 배열 a로 다시 이동

                  while b1 <= e1 and b2 <= e2 do
                          if a[b1] <= a[b2] then  //비교
                                sorted[idx++] <- a[b1++]  //이동
                          else
                                sorted[idx++] <- a[b2++]  //이동
                          endif
                  repeat
                  if b1 <= e1 then  //b1 나머지 원소 삽입  
                          for i <- b1 to e1 do
                                  sorted[idx++] <- a[b1++] //이동
                          repeat
                  else
                          for i <- b2 to e2 do //b2 나머지 원소 삽입
                                  sorted[idx++] <- a[b2++]  //이동
                          repeat
                  endif

                  for i <- low to high do //sorted를 a로 이동
                          a[i] <- sorted[i] //이동
                  repeat      
          }

          1-4. 알고리즘 시간 복잡도
          merge_sort(list: array of integers, left, right: integer)
          {
                    if left < right then  //비교 발생
                            mid = (left + right)/2  
                            merge_sort(list, left, mid);  #재귀 호출
                            merge_sort(list, mid +1, right); #재귀 호출
                            merge(list, left, mid, right);
                    endif
          }

          비교 횟수: 리스트의 크기가 n일 경우 log2n 각 단계에서 n번 비교 -> O(nlog2n)

          이동 횟수: merge에서만 발생, 2nlog2n (비교횟수의 2배) -> O(nlog2n)


          평가
            1. 최악, 평균, 최상의 경우 차이가 없다

            2. 단점으로 임시 배열을 사용하고 이동횟수가 많다.

            3. 연결리스트로 표현시 퀵정렬보다 효율적

            4. 합병 정렬은 외부 정렬시 사용되고, 정렬알고리즘 병렬화에 사용


          연결리스트로 표현
            10 -> 22 -> 30 -> 35 -> 13 -> 24 -> 25 -> 35
            //포인터의 위치 활용만 사용하면 데이터의 이동없이 사용할 수 있다

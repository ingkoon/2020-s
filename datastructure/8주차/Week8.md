# 8주차 (1)

## 그래프
* 그래프에 대해서
  * V(G) = 정점들의 집합
  * E(G) = 간선들의 집합
* 경로
  * G에서 2개의 정점, vp부터 vq까지의 경로는 다음 정점의 시퀀스이다.
  * 단순경로
    * 처음과 끝의 정점을 제외하고는 모든 정점들이 서로 다른 경로
  * 사이클
    * 처음과 끝의 정점이 동일한 단순 경로
    * 다음 그래프 G에 대해서 답하시오.

## 연결 컴포넌트
  * 최대로 연결된 부분 그래프를 그래프의 연결 컴포넌트라고 함
    * 연결된 부분 그래프 중에서 크기가 최대인 것

## 그래프 ADT
* 객체: 정점의 집합과 간선의 집합
* 연산
  * create_graph() = 그래프 생성
  * init(g) = 그래프 g를 초기화 한다.
  * insert_vertex(g, x) = 그래프 g에 정점 v를 삽입한다.
  * insert_edge(g, E, v) = 그래프 g에 (E, v)를 삽입한다.
  * delete_edge(g, E, v) = 그래프 g의 간선 (u, v)를 삭제한다.
  * is_empty(g) = 그래프 g가 공백 상태인지 확인한다.
  * adjacent (v)= 정점 v에 인접한 정점들의 리스트를 반환한다.
  * destroy_graph(g) = 그래프 g를 제거한다.

##그래프 표현방법
* 인접 행렬
  * G = (V, E), |V| = n이면, G의 인접행렬은 n*n 행렬 M으로 다음과 같이 표현:
    * M[i,j] =  iff (vi, vj) E E(G) (<vi, vj> E E(G), 방향 그래프이면) = 0 iff otherwise

  * 무방향 그래프에서 인접 행렬은 대칭적인가?
    * 행렬의 상위나 하위 삼각형 부분만 저장 가능.

  * 방향 그래프에서 인접행렬은 대칭적인가?
    * 대칭적이지 못하다.

  * G = (V, E), |V| = n일때,
    * 인접 행렬 표현을 위한 필요한 메모리양은 ?
      * n*n개의 행렬이 필요하다.
    * 두 정점간의 간선의 존재 여부에 대해 어떻게 아는가
      * i,j -> V을 알기 위해선, M[i, j] == 1임을 알면 된다.
    * 정점 i의 차수를 어떻게 구하는가? = 부속된 간선의 개수는
<pre>
<code>
int cnt <- 0;
for k <- 0 to n-1 do
  if M[i,k] == 1 then
    cnt++;
  endif
repeat
</code>
</pre>
    * G상에 존재하는 간선의 개수를 어떻게 구하는가?
      * for문을 하나 더 사용하여 M[i, j]의 개수를 구한다.
<pre>
<code>
int cnt = 0;
for k = 0 to n-1 do
    M[i,k] == 1
      cnt++;
repeat
</code>
</pre>

  * 방향그래프의 인접 행렬 표현에서
    * 진입 차수는 어떻게 구하는가?
      * for k <- 0 to n -1 do M[k,i] repeat
    * 진출 차수는 어떻게 구하는가?
      * for k <- 0 to n -1 do M[i,k] repeat

* 인접 리스트
  * G = (V, E), |V| = n이면 n개의 연결 리스트로 표현
    * 각 정점
  * 인접행렬 방법
    * G = (V, E), |V| = n이면 G의 인접 행렬은 n*n 행렬 M으로 다음과 같이 표현:
      * M[i,j] = 1 iff (vi, vj) E E(G) (<vi, vj> E E(G), 방향 그래프이면) = 0 iff otherwise

    * 리스트 노드의 개수는 2e
    * 두 정점 i, j간에 간선의 존재 여부를 어떻게 아는가?

* 정점의 개수와 행렬을 포함하는 구조체로 표현
<pre>
<code>
#define MAX 50
typedef struct graphType
</code>
</pre>

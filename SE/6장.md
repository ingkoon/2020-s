# 6장/7장
----------
## 아키텍쳐와 패턴

### 아키텍쳐
* 서브 시스템 수준의 덩어리화 작업
* 다양한 수준에서 구성 요소의 역할과 구성 요소간의 관계에 집중 + 클래스 수준 이상의 그룹핑과 역할, 인터페이스를 정의하는 작업
  - 컴퓨터 구조: 전체 시스템에 대한 구조를 나타낸다.
  - 2-tier: 클라이언트 서버 관계
  - 3-tier: 클라이언트 미들웨어(래퍼) 서버 관계

### 아키텍처의 역할
* 시스템의 구조를 확립하는 **소프트웨어 개발의 중심축**
* **설계, 구현과 통합, 테스팅까지 통합하는 뼈대**
* 모든 단계에 영향을 줄 만한 **초기 의사 결정의 핵심**
  - 아키텍처 구성요소 안에서 이루어지는 상세 설계에서 필요한 지식
    - 디자인패턴 (싱글톤 패턴, 중재자 패턴...)

### 아키텍처 스타일
* 일반적인 모양과 조화를 위한 스타일을 정하는 작업
  - 시스템 분할, 전체 제어 흐름, 오류 처리 방침, 서브시스템 간의 통신 프로토 콜 포함
* 구성 요소 유형에 대한 설명 및 런 타임 제어, 데이터 전송에 대한 패턴
* 주요 스타일(☆)
  - 클라이언트 서버형
  - 계층형
  - 이벤트 기반 아키텍처
  - MVC
  - 파이프 필터
  - 데이터 중심 아키텍처
  - Peer-to-Peer 스타일

### 클라이언트 서버형(->확장->클라우드 )
* 서버 - **강력한 성능으로 자원을 관리**하며 클라이언트가 요청하는 기능이나 자원을 제공
* 클라이언트 - 자원의 사용을 위하여 **서버를 접속**
  - 장점: 데이터 집중화, 보안 (☆)
  - 단점: 병목, 비용, 비강인성(결함 허용: fault tolerance) (☆)
  - 서버가 고장이나면 클라이언트는 더이상 동작불가능, 서버가 복구될 때까지 클라이언트는 상호작용 할 수 없음.

### 계층형
* 소프트웨어의 기능을 **수직으로 상호작용하는 여러 층으로 분할**
* 각 층 사이는 메시지를 교환
* 장점 - 추상화(**각 레이어의 역할과 책임, 관계를 잘 이해할 수 있음**), 캡슐화, 응집높음, 재사용(각 층의 의존도가 적어 다른 모듈로 교환가능, 다른시스템에서 사용가능)(☆)
* 단점 -  이웃층과의 커뮤니케이션이 제한적(☆)

### 이벤트기반 아키텍처
* 이벤트 스트림을 생성하는 **이벤트 생산자**
* 이벤트를 수신 대기하는 **이벤트 소비자**로 구성
* 이벤트
  - 실시간으로 전달되어 발생하는 즉시 소비자가 이벤트에 응답할 수 있어야
* 상태기반 처리
  - 이벤트 생산자 -> 이벤트 처리기 -> 이벤트 소비자
* 이벤트 중심 시스템(행위의 존재 유무에 따른 시스템)
  - 엘리베이터, IOT 시스템 설계
  - 장점: 캡슐화, 응집, 확장성(시스템에 이벤트 소비자 추가가 쉬움, 하위 시스템에서 이벤트 스트림을 독립적으로 확인 가능)
  - 단점: 복잡성(상태에 따라서 복잡하고 정교한 제어 필요), 테스팅

### MVC (model-view-controller)
* 사용자 인터페이스로부터 비즈니스 로직과 데이터를 분리
* 컨트롤러-모델에 명령을 보냄으로써 모델의 상태를 변경함
* 모델-데이터의 상테에 변화가 있을 떄 컨트롤러와 뷰에 이를 통보
* **뷰-사용자가 볼 결과물을 생성하기 위해 모델로부터 정보를 얻어 옴**
  - 워드 프로세서
    - 컨트롤러: 문서 편집을 담당하는 부분(컨트롤러가 **뷰**에 명령을 보내서 **모델**의 표시방법을 바꿀 수 있다)
      - ->문서 스크롤 명령

  - 장점: loose coupled(), 확장성, 다수의 다른 뷰(하나의 모델을 위하여 다수의 뷰를 쉽게 제공, 데이터와 비즈니스 로직이 분리되어 있기 때문에 **코드 중복이 적음**), 비동기화
  - 단점: 컴포넌트가 분리되어 있기 때문에 복잡도 증가, 비효율성(뷰에서 데이터를 접근해야함)

### 파이프 필터
* 필터 사이에 데이터를 이동시키며 단계적으로 처리
* 데이터의 변환을 수행하는 필터 구성 요소로 구성(예: 컴파일러)
  - 장점: 단순성, 재사용, 병렬성
  - 단점: 자원의 낭비

### 데이터 중심 아키텍처
* 공유 데이터 저장소와 공유 데이터 접근자로 구성
* 접근자는 **공유 데이터를 추가, 삭제 및 수정**
* 블랙보드 - 제어 스레드 포함, 옵서버 디자인 패턴 사용
* 리파지토리 - 공유 데이터를 질의하여 변경 사항을 발견
  - 장점: 루즈 커플드, 확장성
  - 단점: 단일장애지점(공유 데이터의 장애로 전체 장애 발생)

### Peer-2-Peer
* 각 컴포넌트는 **동등하여 서비스를 요청하는 클라이언트, 동시에 서비스를 제공하는 서버**역할
* 동일한 **수신, 전송 데이터 양을 가지므로 대칭적인 시스템**
  - 장점: 전담 애플리케이션, 서버가 없음, 확장성, 결함 허용
  - 단점: 보안취약, 중앙제어 불가능, 자원이 공유로 인한 성능 하락

### 디자인 패턴
* 아키텍처 설계 수준보다 낮은 수준의 설계 문제에 재사용 가능한 솔루션을 제공
  - ex)시스템이 자료갱신 시 컨트롤과 함께 재고자료 표시해야 된다는 요구사항
  - 아키텍처는 MVC
  - 시스템 타입: 대화형 시스템
  - MVC 스타일을 구현하기 위해 뷰에 모델의 가장 최근 변경사항이 반영되도록 하는 방법 -> 디자인 패턴

* 시스템 타입
- 대화형 시스템
- 이벤트 중심
- 변환 시스템(컴파일러)
- 객체영속 시스템(저장 미디어를 숨기고, 데이터베이스나 파일 시스템에 객체를 저장하고 검색하는 기능이 있는 시스템)

### 디자인 패턴의 혜택
* 쉽게 **재사용 가능**
* 설계 **작업이 쉬워짐**
* **설계 관련 지식이 정리됨**
* 디자인을 논의하기 위한 **의사소통이 쉬워짐**
* 객체지향 설계 원리를 따르게 됨

### 싱글톤 패턴
* 객체를 강제적으로 하나만 생성하려는 목적
  - 예: DB 커넥션을 위한 인터페이스
* 방법
  - 클래스 자체를 **정적 변수**로
  - 생성자는 private로 선언
  - 유일한 객체를 접근하는 정적 메소드
* 문제: 데이터베이스에 대한 인터페이스 제공 클래스 -> 다중 데이터베이스 연결 비용이 많이 들고, 지원이 되지 않는 문제점
* 솔루션: 클래스안에 자신을 static 속성 -> 객체가 유일 클래스의 생성자 -> private

### 반복자 패턴  
* 집합 클래스의 **자료구조와 상관없이 집합에 소속된 요소들을 쉽게 접근하기 위하여 반복자에게 위임
* 클라이언트가 **특정 집합의 유형과 유형별로 접근하고 집계하는 방법을 신격쓰지 않아도 됨**

* 문제: 벡터나 트리, 리스트 등의 집합구조와 함께 사용하면 client가 특정 집합의 유형과 유형별로 접근하고, 총 집계하는 방법을 신경쓰지 않아도 됨
* 솔루션: 반복 수행하는 집합 클래스에 대해 접근하는 반복자를 iterator 인터페이스로 정의, 집합에 의해 구현될 aggregate 인터페이스를 정의

### 어댑터 패턴
* 사용 가능한 서비스의 인터페이스를 **클라이언트가 예상하는 인터페이스에 맞게 조정**
* 어댑터 - **서비스가 제공하는 인터페이스를 클라이언트가 기대하는 인터페이스로 변환**

### 팩토리 메소드 패턴
* 클라이언트에서 사용할 클래스의 객체를 생성하는 책임을 분리하여 객체 생성에 변화를 대비
* 객체를 생성하기 위한 **팩토리 메소드**를 포함하는 **추상 클래스**를 정의
- 예시) 자동차 견적을 내달라 할때, 클라이언트를위한 어떠한 추상적인 차 모델을 정의

### 추상 팩토리 패턴
* 객체를 사용할 클라이언트에서 구체적인 객체 생성을 지정하는 책임을 분리하기 위하여 **추상 인터페이스를 이용하여 관련 객체 패밀리를 생성**
- 예시)

### 상태 패턴
* **상태에 따라 객체의 동작을 변경**해야 하는 경우
* 맥락과 상태를 별도로 구현하여 융통성을 달성하기 위한 **체계적이고 느슨한 결합방식**

### 옵서버 패턴
* 데이터를 보관하고 있는 Subject가 그 데이터를 이용하는 옵서버와 효과적으로 통신하면서 느슨하게 결합
* Subject 클래스 - 옵서버 목록을 유지, 변경을 고지
* Observer 클래스 - 변경을 통지받고 접근을 요청

### 아키텍처 평가
* 아키텍처나 디자인 패턴의 속성, 강점 및 약점을 결정하는 방법
* 개발자가 선택한 아키텍처가 기능적 및 비기능적 품질 요구사항을 모두 충족시킬 수 있음을 보증
  - SAAM: 시나리오 기반 평가 방법
  - ATAM: 여러가지 품질 속성에 초점을 맞추어 평가

### SAAM
* 아키텍처가 시나리오를 실행할 수 있는지 여부를 결정
  - 실행하지 못하는 경우, 시나리오를 지원하도록 아키텍처를 변경
* 여러 이해 당사자를 통하여 시나리오 도출
* 시나리오
  - 직접: 시스템의 변경이 요구되지 않는 시나리오
  - 간접: 시스템의 변경이 요구되는 시나리오, 새로운 기능을 추가하거나 원하지 않는 기능을 삭제

#### ATAM
* 여러가지 품질 속성에 초점을 맞추어 평가하여 아키텍처의 Trade-off, 설계 **타협점**을 찾아냄
* 아키텍처 내부의 리스크를 발견
